import warnings
from copy import deepcopy
from typing import Union, Tuple, Dict, Optional, List, Set, Sequence
from collections.abc import Mapping
from os.path import basename, dirname, abspath
import os

import numpy as np
from ase.io.extxyz import read_extxyz
import ase.neighborlist
import ase
from tqdm import tqdm
from ase.calculators.singlepoint import SinglePointCalculator, SinglePointDFTCalculator
from ase.calculators.calculator import all_properties as ase_all_properties
from ase.stress import voigt_6_to_full_3x3_stress, full_3x3_to_voigt_6_stress

import torch
from torch import utils
from torch_geometric.data import Data
from torch_geometric.data import InMemoryDataset, Dataset
from torch_geometric.data import LightningDataset


class MolecularDataset(Dataset):
    '''
    A demo code for Mingzheng Zhang task of gas separation
    Attention! The molecular system with no periodic,
    so we can use the get_distance by pyg.
    '''

    def __init__(self,
                 root: str,
                 dir_name: str,
                 transform=None,
                 pre_transform=None,
                 pre_filter=None):
        self.dir_name = dir_name
        super().__init__(root, transform, pre_transform, pre_filter)

    @property
    def raw_file_names(self):
        raise NotImplementedError()

    @property
    def processed_file_names(self) -> str:
        raise NotImplementedError()

    def download(self):
        pass

    def process(self):
        raise NotImplementedError

    def len(self):
        return len(self.processed_file_names)

    def get(self, idx):
        data = torch.load(os.path.join(self.processed_dir, f'data_{idx}.pt'))
        return data


class MolDataset(MolecularDataset):
    def __init__(self,
                 root: str,
                 dir_name: str,
                 transform=None,
                 pre_transform=None,
                 pre_filter=None
                 ):
        # self.r_cut = r_cut
        # self.file_name=file_name
        super().__init__(root, dir_name, transform, pre_transform, pre_filter)

    @property
    def raw_file_names(self):
        return os.listdir(self.raw_dir)

    @property
    def raw_dir(self):
        return abspath(self.dir_name)

    @property
    def processed_file_names(self):
        return [f'data_{idx}.pt' for idx in range(len(self.raw_file_names))]

    def process(self):
        for idx in tqdm(range(len(self.raw_file_names))):
            filename = self.raw_dir + "/" + self.raw_file_names[idx]
            atoms = ase.io.read(filename)
            pos = torch.as_tensor(atoms.positions, dtype=torch.get_default_dtype())
            z = torch.as_tensor(atoms.numbers, dtype=torch.get_default_dtype())
            total_energy = torch.as_tensor(atoms.info['energy'], dtype=torch.get_default_dtype())
            data=Data(z=z, pos=pos, total_energy=total_energy.reshape(-1, 1))
            torch.save(data, os.path.join(self.processed_dir,self.processed_file_names[idx]))

class AtomicInMemoryDataset(InMemoryDataset):
    '''
    Now all neighbor list will be generated by the ASE.
    '''

    def __init__(self,
                 root: str,
                 file_name: str,
                 transform=None,
                 pre_transform=None,
                 pre_filter=None):
        self.file_name = file_name
        super().__init__(root, transform, pre_transform, pre_filter)

    @property
    def raw_file_names(self):
        raise NotImplementedError()

    @property
    def raw_dir(self):
        raise NotImplementedError()

    @property
    def processed_file_names(self) -> str:
        return 'data.pt'

    # def get_data(self) -> :
    #     raise NotImplementedError

    def download(self):
        pass

    def process(self):
        raise NotImplementedError

    def _mean(self, target: str) -> float:
        y = torch.cat([self.get(i)[target] for i in range(len(self))], dim=0)
        return float(y.mean())

    def _std(self, target: str) -> float:
        y = torch.cat([self.get(i).y for i in range(len(self))], dim=0)
        return float(y[:, target].std())

    def len(self):
        if self.data is None:
            return 0
        return len(self.data)

    def statistics(self, target='atomic_energy', state='mean'):
        if state == 'mean':
            if target == 'atomic_energy':
                tmp_target = 'total_energy'
                list = torch.cat([self.get(i)[tmp_target] / len(self.get(i)['z']) for i in range(len(self))])
                mean = float(list.mean())
            else:
                mean = self._mean(target)
            return mean

        else:
            raise ValueError(f'Now we can only deal with mean!')

    def _neighbor_list_and_relative_vec(
            self,
            pos,
            r_max,
            self_interaction=False,
            strict_self_interaction=True,
            cell=None,
            pbc=False,
    ):
        """
        Create neighbor list and neighbor vectors based on radial cutoff.
        Create neighbor list (``edge_index``) and relative vectors
        (``edge_attr``) based on radial cutoff.
        Edges are given by the following convention:
        - ``edge_index[0]`` is the *source* (convolution center).
        - ``edge_index[1]`` is the *target* (neighbor).
        Thus, ``edge_index`` has the same convention as the relative vectors:
        :math:`\\vec{r}_{source, target}`
        If the input positions are a tensor with ``requires_grad == True``,
        the output displacement vectors will be correctly attached to the inputs
        for autograd.
        All outputs are Tensors on the same device as ``pos``; this allows future
        optimization of the neighbor list on the GPU.
        Args:
            pos (shape [N, 3]): Positional coordinate; Tensor or numpy array. If Tensor, must be on CPU.
            r_max (float): Radial cutoff distance for neighbor finding.
            cell (numpy shape [3, 3]): Cell for periodic boundary conditions. Ignored if ``pbc == False``.
            pbc (bool or 3-tuple of bool): Whether the system is periodic in each of the three cell dimensions.
            self_interaction (bool): Whether or not to include same periodic image self-edges in the neighbor list.
            strict_self_interaction (bool): Whether to include *any* self interaction edges in the graph, even if the two
                instances of the atom are in different periodic images. Defaults to True, should be True for most applications.
        Returns:
            edge_index (torch.tensor shape [2, num_edges]): List of edges.
            edge_cell_shift (torch.tensor shape [num_edges, 3]): Relative cell shift
                vectors. Returned only if cell is not None.
            cell (torch.Tensor [3, 3]): the cell as a tensor on the correct device.
                Returned only if cell is not None.
        """
        if isinstance(pbc, bool):
            pbc = (pbc,) * 3

        if cell is not None:
            temp_cell = np.asarray(cell)
            cell_tensor = torch.as_tensor(temp_cell, dtype=torch.get_default_dtype())
        else:
            # ASE will "complete" this correctly.
            temp_cell = np.zeros((3, 3), dtype=torch.get_default_dtype())
            cell_tensor = torch.as_tensor(temp_cell, dtype=torch.get_default_dtype())

        # ASE dependent part
        temp_cell = ase.geometry.complete_cell(temp_cell)

        '''
        As you know, we do not need to calc the distance now.
        For use the autograd, the distance can be calculated in every iter

        TODO:
        clean this neighbor_list function, we do not need to calc the distance now.
        '''
        first_idex, second_idex, shifts = ase.neighborlist.primitive_neighbor_list(
            "ijS",
            pbc,
            temp_cell,
            pos,
            cutoff=float(r_max),
            self_interaction=strict_self_interaction,
            # we want edges from atom to itself in different periodic images!
            use_scaled_positions=False,
        )

        # Eliminate true self-edges that don't cross periodic boundaries

        if not self_interaction:
            # print('well, the self_interaction may has something bad!')
            bad_edge = first_idex == second_idex
            bad_edge &= np.all(shifts == 0, axis=1)
            keep_edge = ~bad_edge
            if not np.any(keep_edge):
                raise ValueError(
                    "After eliminating self edges, no edges remain in this system."
                )
            first_idex = first_idex[keep_edge]
            second_idex = second_idex[keep_edge]
            shifts = shifts[keep_edge]
            # dist = dist[keep_edge]

        # Build output:
        edge_index = torch.vstack(
            (torch.LongTensor(first_idex), torch.LongTensor(second_idex))
        )

        shifts = torch.as_tensor(
            shifts,
            dtype=torch.get_default_dtype()
        )

        # edge_weight = torch.as_tensor(dist, dtype=torch.get_default_dtype())

        return edge_index, shifts, cell_tensor

class ASEDataset(AtomicInMemoryDataset):
    '''
    Now ASEDataset hasn't the atomic energy
    '''

    def __init__(self,
                 root: str,
                 file_name: str,
                 transform=None,
                 pre_transform=None,
                 pre_filter=None,
                 statistics=True,
                 r_cut: float = 4.0
                 ):
        self.statistic_flag = statistics
        self.r_cut = r_cut
        # self.file_name=file_name
        super().__init__(root, file_name, transform, pre_transform, pre_filter)
        # file_name=file_name
        self.data = torch.load(self.processed_paths[0])

    @property
    def raw_file_names(self):
        return [basename(self.file_name)]

    @property
    def raw_dir(self):
        return dirname(abspath(self.file_name))

    def _ase_data_reader(self, filename, r_cut):
        datas = []
        images = ase.io.read(filename, index=':')
        for atoms in tqdm(images):
            pos = torch.as_tensor(atoms.positions, dtype=torch.get_default_dtype())
            z = torch.as_tensor(atoms.numbers, dtype=torch.get_default_dtype())
            total_energy = torch.as_tensor(atoms.info['energy'], dtype=torch.get_default_dtype())
            atomic_energy = torch.as_tensor(atoms.arrays['energies'], dtype=torch.get_default_dtype())
            force = torch.as_tensor(atoms.arrays['forces'], dtype=torch.get_default_dtype())
            edge_index, edge_cell_shift, cell = self._neighbor_list_and_relative_vec(atoms.positions, r_max=r_cut,
                                                                                     cell=atoms.cell,
                                                                                     pbc=atoms.pbc)
            temp_datas = Data(z=z, pos=pos, total_energy=total_energy.reshape(-1, 1),
                              atomic_energy=atomic_energy.reshape(-1, 1), force=force, edge_index=edge_index,
                              cell=cell.unsqueeze(0), offset=edge_cell_shift)
            datas.append(temp_datas)
        return datas

    def process(self):
        filename = self.raw_dir + "/" + self.raw_file_names[0]
        datas = self._ase_data_reader(filename, self.r_cut)
        # self.collate(datas)
        # torch.save(self.collate(datas),os.path.join(self.processed_paths[0]))
        torch.save(datas, os.path.join(self.processed_paths[0]))
        # print(1)

    def get(self, idx):
        out = self.data[idx]
        return out

if __name__ == '__main__':
    # a=read_extxyz('../cu1000.xyz')
    # a = ASEDataset(root='cu1000', file_name='cu1000_AtomicE.xyz', r_cut=4)
    a = MolDataset(root='Mol_zmz',dir_name='Molecular')
    test = LightningDataset(a)
    train_loader = utils.data.DataLoader(test)
    print(a.statistics())
